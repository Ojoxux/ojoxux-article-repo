---
title: "型安全な正規表現？ArkRegex 入門"
emoji: "🛡️"
type: "tech"
topics: ["typescript", "regex", "arktype", "正規表現", "型安全"]
published: false
---

# 型安全な正規表現？ArkRegex 入門

最近 X で見かけた ArkRegex という正規表現を型安全に扱えるライブラリについて紹介したいと思います。

正規表現って JavaScript で文字列を扱うときに便利なんですが、TypeScript で使っても型情報がほとんど失われてしまうんですよね。特にキャプチャグループを使うときなんかは、`groups`のプロパティ名も補完されないし、タイプミスしても気づけない...そんな悩みを解決してくれるのが ArkRegex です。

https://x.com/arktypeio/status/1983210635266498649?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1983210635266498649%7Ctwgr%5E8ff7893c7ba7a6159d44a92b6da3088d98e99a01%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fembed.zenn.studio%2Ftweetzenn-embedded__0b32ae7707072

## ArkRegex とは

ArkRegex は、公式によると`new RegExp()`の型安全なドロップイン置き換えとのこと。

普段`new RegExp()`を使っているところを ArkRegex に置き換えるだけで、以下のようなメリットが得られます。

- 正規表現パターンから文字列の型が推論される
- 構文エラーが型エラーとして検出される
- `.test()`で型の絞り込みができる
- `.exec()`のキャプチャグループが型安全になる

## セットアップ

インストールは簡単で、以下のコマンドを実行するだけです。

```bash
pnpm install arktype arkregex
```

VSCode を使っている方は、[ArkType 拡張機能](https://marketplace.visualstudio.com/items?itemName=arktypeio.arktype)を入れると`regex`呼び出しにシンタックスハイライトが付いて見やすくなるのでおすすめです。

## まずは使ってみる

それでは実際に使ってみましょう。
例として、ユーザー ID のバリデーション（英小文字+数字、3〜12 文字）を作ってみます。

```typescript
import { regex } from "arkregex";

const userId = regex("^[a-z0-9]{3,12}$");

console.log(userId.test("abc123")); // true
console.log(userId.test("ABC")); // false（大文字はNG）
```

使い方自体は普通の`RegExp`と全く同じですね。
でも、IDE で`userId`にマウスホバーしてみると...型情報が付いています！

通常の`RegExp`だとただの`RegExp`型なのに対し、ArkRegex は`Regex<string, {}>`という型になっています。

## 型推論がすげぇ

### 大文字小文字の組み合わせを全部推論

例えば、`i`フラグ（大文字小文字を区別しない）を使った場合、こんなことが起きます。

```typescript
const ok = regex("^ok$", "i");
```

IDE でこの`ok`の型を見ると...

```typescript
Regex<"ok" | "oK" | "Ok" | "OK", { flags: "i" }>;
```

なんと、大文字小文字の全組み合わせがユニオン型として推論されてる！
これは地味にすごいですね。

### オプショナルなパターンも

もっとすごいのがこれです。電話番号のパターンで、ハイフンがあってもなくても OK にしたい場合。

```typescript
const phone = regex("^0\\d{1,4}-?\\d{1,4}-?\\d{4}$");
```

この型を見ると...

```typescript
Regex<
  | `0${bigint}${bigint}${bigint}` // ハイフンなし
  | `0${bigint}-${bigint}${bigint}` // 1つ目だけ
  | `0${bigint}${bigint}-${bigint}` // 2つ目だけ
  | `0${bigint}-${bigint}-${bigint}`, // 両方あり
  {}
>;
```

ハイフンが 2 箇所で`-?`になっているから、2² = 4 パターン全部が型に表現されています。
これが「型推論が効いている」状態なんですね。

もちろん実際に動かしても期待通りです。

```typescript
console.log(phone.test("090-1234-5678")); // true
console.log(phone.test("09012345678")); // true
console.log(phone.test("090-12345678")); // true
```

## キャプチャグループが型安全に

個人的に一番嬉しいのがこれです。

### 位置指定キャプチャグループ

セマンティックバージョニングのパターンを書いてみます。

```typescript
const semver = regex("^(\\d+)\\.(\\d+)\\.(\\d+)$");

const match = semver.exec("2.1.25");
if (match) {
  console.log(match[0]); // "2.1.25"
  console.log(match[1]); // "2"
  console.log(match[2]); // "1"
  console.log(match[3]); // "25"
}
```

これだけなら普通なんですが、`match[0]`の型を見ると`` `${bigint}.${bigint}.${bigint}` ``になっています。
つまり、「数字.数字.数字」という形式だと型レベルで分かるわけです。

### 名前付きキャプチャグループ

さらに便利なのが名前付きキャプチャグループです。
メールアドレスをパースしてみましょう。

```typescript
const email = regex("^(?<name>\\w+)@(?<domain>\\w+\\.\\w+)$");

const match = email.exec("user@example.com");
if (match && match.groups) {
  console.log(match.groups.name); // "user"
  console.log(match.groups.domain); // "example.com"
}
```

ここで`match.groups.`まで入力すると、IDE で`name`と`domain`が補完されます！
普通の`RegExp`だと`groups`の型は`{ [key: string]: string }`なので補完されないんですよね。

しかも、タイプミスすると型エラーになります。

```typescript
// これは型エラーになる
// console.log(match.groups.namee); // ❌ Property 'namee' does not exist
```

これで「typo で実行時エラー」という悲しい事故を防げます。

## 実際に使えそうなパターン

いくつか実用的なパターンを試してみました。

### 郵便番号

```typescript
const postalCode = regex("^(\\d{3})-(\\d{4})$");
const match = postalCode.exec("123-4567");
if (match) {
  console.log(match[1]); // "123"
  console.log(match[2]); // "4567"
}
```

### URL

```typescript
const url = regex(
  "^(?<protocol>https?)://(?<host>[\\w.-]+)(?<path>/[\\w/.-]*)?$"
);

const match = url.exec("https://arktype.io/docs/blog/arkregex");
if (match && match.groups) {
  console.log(match.groups.protocol); // "https"
  console.log(match.groups.host); // "arktype.io"
  console.log(match.groups.path); // "/docs/blog/arkregex"
}
```

`groups.protocol`の型は`"http" | "https"`になっていて、`groups.path`は`` `/${string}` | undefined ``です。
オプショナルなグループも正しく`undefined`が入っています。

### ハッシュタグの抽出

`g`フラグを使った例も試してみます。

```typescript
const hashtag = regex("#(\\w+)", "g");
const text = "TypeScriptが好き！ #typescript #arktype #arkregex で型安全に！";
const tags = text.match(hashtag);

console.log(tags);
// ["#typescript", "#arktype", "#arkregex"]
```

ちゃんと全部拾えていますね。

### 日付

```typescript
const datePattern = regex("^(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})$");
const match = datePattern.exec("2025-10-30");

if (match && match.groups) {
  console.log(match.groups.year); // "2025"
  console.log(match.groups.month); // "10"
  console.log(match.groups.day); // "30"
}
```

## zod と組み合わせる

zod を使っている人も多いと思うので、組み合わせの例も書いておきます。

```typescript
import { z } from "zod";
import { regex } from "arkregex";

const email = regex("^(?<name>\\w+)@(?<domain>\\w+\\.\\w+)$");

const userSchema = z.object({
  email: z.string().refine((val) => email.test(val), {
    message: "Invalid email format",
  }),
  age: z.number().min(0),
});
```

「文字列版の zod」みたいに感じるかもしれませんが、開発者のコメントによると`z.templateLiteral`や`z.stringFormat`に近い機能らしいです。

ちなみに、本当の「文字列版の zod」は[ArkType](https://arktype.io/)の方を指すことが多いとのこと。
ArkType は型安全なバリデーションライブラリで、ArkRegex はそのエコシステムの一部なんですね。

ArkType についてはいろんなところ記事で紹介されているので、興味がある方はぜひ。

## パフォーマンスは？

これも気になるポイントですが、ArkRegex は**ゼロランタイムオーバーヘッド**です。

型チェックはコンパイル時にしか行われないので、ビルド後の JavaScript は普通の`RegExp`と全く同じ。
つまり、実行時のパフォーマンスに影響はありません。

バンドルサイズも増えないし、型安全性だけが手に入るというわけです。

## まとめ

ArkRegex いかがでしたでしょうか。

個人的には、名前付きキャプチャグループの補完が効くのが一番嬉しいですね。
今まで「これ何だっけ？」ってなってソースを見に行くことが多かったので。

あと、型ガードと型定義の同期問題も解決できそうなのが良いです。
正規表現から型を導出できるので、一箇所直せば全部に反映されます。

正規表現を多用するプロジェクトで、型安全性を高めたい方にはおすすめできると思います。

ただ、まだ比較的新しいライブラリ（v0.0.2）なので、大規模プロダクションに入れる前にはちゃんと検証した方が良さそうです。
とはいえ、公式もかなりテストしているみたいなので、そこまで心配はいらないかもしれません。

気になった方はぜひ試してみてください！

## 参考リンク

- [ArkType ブログ](https://arktype.io/docs/blog/arkregex)
- [GitHub リポジトリ](https://github.com/arktypeio/arktype)
